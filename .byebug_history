c
@order
c
self.order
c
request.subdomain
n
c
n
request.subdomain
current_user
c
self
self.left = self.quantity
self
c
params[:q]
params
params[:from]
c
params[:from]
params
c
x.errors.full_messages
x.errors.count
x.valid?
x=order.order_items.new(item_id: params[:item_id], quantity: params[:quantity])
order.order_items.new(item_id: params[:item_id], quantity: params[:quantity]).errors.count
order.order_items.new(item_id: params[:item_id], quantity: params[:quantity]).errors
order.order_items.new(item_id: params[:item_id], quantity: params[:quantity]).valid?
order.order_items.new(item_id: params[:item_id], quantity: params[:quantity])
c
self.item.left
self.order.status
self
dself
c
@order.order_items.where(status: 'Out')
@order.order_items.where(status: 'out')
@order.order_items
@order
c
exit
c
request.subdomain
root_path
c
current_user
c
current_user
c
request.host
c
request.host
request.root
request.domain
request.subdomain
resource
root_path
c
resource
c
root_path
root_url
request.referrer
c
params
resource
c
resource.errors.count
resource
resourice
c
@oi
c
item_id
self.item_id
c
left
n
quantity
item.left
c
self.item
item.left
c
self.valid?
self.is_valid?
self
c
exit
Date.today
created_at.to_date
created_at
status
c
order_items.map(&:make_response)
order_items
n
(days*self.item.charge.to_i)
self
days
n
c
days*self.item.charge.to_i
n
days
days*self.item.charge.to_i
calculate_days
c
n
order_item
n
exit
self.created_at.to_date
self.created_at
Date.parse(self.created_at)
self.created_at
Date.today
c
order.order_items
c
items.count
c
name
ddname
